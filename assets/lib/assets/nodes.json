{
  "type": "document",
  "data": { "version": "1" },
  "nodes": [
    {
      "type": "title",
      "text": "编辑器测试",
      "data": { "level": 1 }
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "颜色"
        },
        {
          "type": "span",
          "text": "红b",
          "data": {
            "bgColor": "#redBg#"
          }
        },
        {
          "type": "span",
          "text": "蓝a",
          "data": {
            "bgColor": "#blueBg#"
          }
        }
      ]
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "AB"
        },
        {
          "type": "span",
          "nodes": [
            {
              "type": "span",
              "text": "C"
            },
            {
              "type": "widget",
              "data": {
                "width": 80
              }
            },
            {
              "type": "widget",
              "data": {
                "width": 80
              }
            }
          ]
        },
        {
          "type": "widget",
          "data": {
            "width": 80
          }
        },
        {
          "type": "span",
          "text": "E"
        }
      ]
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "颜色"
        },
        {
          "type": "span",
          "text": "红b",
          "data": {
            "bgColor": "#redBg#"
          }
        },
        {
          "type": "span",
          "text": "红a",
          "data": {
            "bgColor": "#redBg#"
          }
        },
        {
          "type": "span",
          "text": "红c",
          "data": {
            "bgColor": "#redBg#"
          }
        },
        {
          "type": "span",
          "text": "颜色"
        }
      ]
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "颜色"
        },
        {
          "type": "widget",
          "data": {
            "width": 80
          }
        },
        {
          "type": "widget",
          "data": {
            "width": 80
          }
        },
        {
          "type": "span",
          "text": "颜色"
        }
      ]
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "widget",
          "data": {
            "width": 80
          }
        },
        {
          "type": "span",
          "text": "颜颜"
        },
        {
          "type": "widget",
          "data": {
            "width": 120
          }
        },
        {
          "type": "span",
          "text": "颜颜"
        },
        {
          "type": "widget",
          "data": {
            "width": 30
          }
        },
        {
          "type": "span",
          "text": "颜颜"
        },
        {
          "type": "widget",
          "data": {
            "width": 30
          }
        },
        {
          "type": "span",
          "text": "颜颜"
        },
        {
          "type": "widget",
          "data": {
            "width": 30
          }
        },
        {
          "type": "span",
          "text": "颜颜"
        },
        {
          "type": "widget",
          "data": {
            "width": 30
          }
        },
        {
          "type": "span",
          "text": "颜颜"
        },
        {
          "type": "widget",
          "data": {
            "width": 30
          }
        },
        {
          "type": "span",
          "text": "颜颜颜"
        },
        {
          "type": "widget",
          "data": {
            "width": 30
          }
        },
        {
          "type": "span",
          "text": "颜颜"
        },
        {
          "type": "widget",
          "data": {
            "width": 30
          }
        },
        {
          "type": "span",
          "text": "颜颜"
        },
        {
          "type": "widget",
          "data": {
            "width": 30
          }
        },
        {
          "type": "span",
          "text": "颜颜"
        },
        {
          "type": "widget",
          "data": {
            "width": 30
          }
        },
        {
          "type": "span",
          "text": "颜颜"
        },
        {
          "type": "widget",
          "data": {
            "width": 30
          }
        },
        {
          "type": "span",
          "text": "颜颜"
        },
        {
          "type": "widget",
          "data": {
            "width": 30
          }
        }
      ]
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "这是"
        },
        {
          "type": "widget",
          "data": {
            "width": 30
          }
        },
        {
          "type": "span",
          "text": "https://www.baidu.com/",
          "data": {
            "link": "wwww"
          }
        },
        {
          "type": "widget",
          "data": {
            "width": 30
          }
        },
        {
          "type": "span",
          "text": "https://www.google.com/",
          "data": {
            "link": "abc"
          }
        },
        {
          "type": "span",
          "text": "谷歌",
          "data": {
            "link": "aaaaa"
          }
        },
        {
          "type": "span",
          "text": "内"
        }
      ]
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "这是"
        },
        {
          "type": "widget",
          "data": {
            "width": 30
          }
        },
        {
          "type": "span",
          "text": "https://www.baidu.com/"
        },
        {
          "type": "widget",
          "data": {
            "width": 30
          }
        },
        {
          "type": "span",
          "text": "https://www.google.com/"
        },
        {
          "type": "span",
          "text": "谷歌",
          "data": {
            "link": "aaaaa"
          }
        },
        {
          "type": "span",
          "text": "内"
        }
      ]
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "这是"
        },
        {
          "type": "span",
          "text": "https://www.baidu.com/",
          "data": {
            "link": "wwww"
          }
        },
        {
          "type": "span",
          "text": "https://www.google.com/",
          "data": {
            "link": "abc"
          }
        },
        {
          "type": "span",
          "text": "谷歌",
          "data": {
            "link": "aaaaa"
          }
        },
        {
          "type": "span",
          "text": "内"
        }
      ]
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "这是"
        },
        {
          "type": "span",
          "text": "https://www.google.com/",
          "data": {
            "link": "abc"
          }
        }
      ]
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "https://www.google.com/",
          "data": {
            "link": "abc"
          }
        },
        {
          "type": "span",
          "text": "这是"
        }
      ]
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "这是"
        },
        {
          "type": "span",
          "data": { "color": "#green#" },
          "nodes": [
            {
              "type": "span",
              "text": "AAA"
            },
            {
              "type": "span",
              "text": "BBB"
            }
          ]
        },
        {
          "type": "span",
          "text": "展示"
        },
        {
          "type": "span",
          "text": "谷歌",
          "data": {
            "link": "aaaaa"
          }
        },
        {
          "type": "span",
          "text": " , "
        },
        {
          "type": "span",
          "text": "https://www.google.com/",
          "data": {
            "link": "abc"
          }
        },
        {
          "type": "span",
          "text": "内联代码块"
        }
      ]
    },
    { "type": "paragraph", "text": "B🇬🇧ox👨模型和Constraints" },
    { "type": "paragraph", "text": "布局模型文档" },
    {
      "type": "paragraph",
      "text": "RenderBox 以二维的笛卡尔坐标进行运算。在盒子布局中，约束是最小及最大宽高。在布局过程中，子节点通过选择这些边界内的大小来确定其几何信息。子节点在布局中返回后，由父节点确定该子节点在父坐标系中的位置。注意，子节点的布局并不取决于它的位置，这是因为它的位置直到它从布局中返回后才确定。因此父节点可以在无需重新计算子节点布局的情况下重新定位子节点的位置信息。"
    },
    { "type": "paragraph", "text": "约束" },
    { "type": "paragraph", "text": "BoxConstraints" },
    {
      "type": "paragraph",
      "text": "构造:  可指定四个尺寸来构造, 或是通过 loose / tight 等, 传入Size或是直接传入width/height创建"
    },
    {
      "type": "paragraph",
      "text": "属性: 获取各轴尺寸的属性,  检测是否 tight,  检测是否有边界等等"
    },
    {
      "type": "title",
      "text": "列表示例"
    },
    {
      "type": "list",
      "text": "属性: 获取各轴尺寸的属性,  检测是否 tight,  检测是否有边界等等",
      "data": { "level": 1 }
    },
    {
      "type": "list",
      "text": "属性: 获取各轴尺寸的属性,  检测是否 tight,  检测是否有边界等等, 检测是否有边界等等",
      "data": { "level": 1 }
    },
    {
      "type": "list",
      "text": "属性: 获取各轴尺寸的属性,  检测是否 tight,  检测是否有边界等等",
      "data": { "level": 2 }
    },
    {
      "type": "list",
      "text": "属性: 获取各轴尺寸的属性,  检测是否 tight,  检测是否有边界等等",
      "data": { "level": 3 }
    },
    {
      "type": "list",
      "text": "属性: 获取各轴尺寸的属性,  检测是否 tight,  检测是否有边界等等",
      "data": { "level": 3 }
    },
    {
      "type": "list",
      "text": "属性: 获取各轴尺寸的属性,  检测是否 tight,  检测是否有边界等等"
    },
    {
      "type": "list",
      "text": "属性: 获取各轴尺寸的属性,  检测是否 tight,  检测是否有边界等等"
    },
    {
      "type": "list",
      "text": "属性: 获取各轴尺寸的属性,  检测是否 tight,  检测是否有边界等等"
    },
    {
      "type": "list",
      "text": "属性: 获取各轴尺寸的属性,  检测是否 tight,  检测是否有边界等等",
      "data": { "level": 2, "listType": "ol" }
    },
    {
      "type": "list",
      "text": "属性: 获取各轴尺寸的属性,  检测是否 tight,  检测是否有边界等等",
      "data": { "level": 2, "listType": "ol" }
    },
    {
      "type": "list",
      "text": "属性: 获取各轴尺寸的属性,  检测是否 tight,  检测是否有边界等等",
      "data": { "level": 2, "listType": "tl" }
    },
    {
      "type": "list",
      "text": "属性: 获取各轴尺寸的属性,  检测是否 tight,  检测是否有边界等等",
      "data": { "level": 2, "listType": "tl" }
    },
    {
      "type": "list",
      "text": "属性: 获取各轴尺寸的属性,  检测是否 tight,  检测是否有边界等等",
      "data": { "level": 3 }
    },
    {
      "type": "title",
      "text": "Format 示例"
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "format 用于为文本设置特殊样式, 比如: "
        },
        {
          "type": "span",
          "text": "粗体文本",
          "data": {
            "bold": true
          }
        },
        {
          "type": "span",
          "text": "   "
        },
        {
          "type": "span",
          "text": "bold text",
          "data": {
            "bold": true
          }
        },
        {
          "type": "span",
          "text": "  "
        },
        {
          "type": "span",
          "text": "斜体文本",
          "data": {
            "italic": true
          }
        },
        {
          "type": "span",
          "text": "  "
        },
        {
          "type": "span",
          "text": "下划线",
          "data": {
            "underline": true
          }
        },
        {
          "type": "span",
          "text": "  "
        },
        {
          "type": "span",
          "text": "删除线",
          "data": {
            "lineThrough": true
          }
        },
        {
          "type": "span",
          "text": "  "
        },
        {
          "type": "span",
          "text": "文本色",
          "data": {
            "color": "#red#"
          }
        },
        {
          "type": "span",
          "text": "  "
        },
        {
          "type": "span",
          "text": "背景色",
          "data": {
            "bgColor": "#blueBg#",
            "color": "#red#"
          }
        },
        {
          "type": "span",
          "text": "  "
        },
        {
          "type": "span",
          "text": "小字号",
          "data": {
            "fontSize": "#fsSm#"
          }
        },
        {
          "type": "span",
          "text": "中字号"
        },
        {
          "type": "span",
          "text": "大字号",
          "data": {
            "fontSize": "#fsLg#"
          }
        },
        {
          "type": "span",
          "text": "  文本"
        },
        {
          "type": "span",
          "text": "qwe",
          "data": {
            "superscript": true
          }
        },
        {
          "type": "span",
          "text": "  文本"
        },
        {
          "type": "span",
          "text": "abc",
          "data": {
            "subscript": true
          }
        }
      ]
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "format 可以重叠, 比如: "
        },
        {
          "type": "span",
          "data": {
            "bold": true,
            "italic": true
          },
          "nodes": [
            {
              "type": "span",
              "text": "这是一段"
            },
            {
              "type": "span",
              "data": {
                "fontSize": "#fsLg#"
              },
              "nodes": [
                {
                  "type": "span",
                  "text": "包含复",
                  "data": {
                    "lineThrough": true
                  }
                },
                {
                  "type": "span",
                  "text": "杂样式的",
                  "data": {
                    "color": "#red#"
                  }
                },
                {
                  "type": "span",
                  "text": "文本",
                  "data": {
                    "bgColor": "#orangeBg#"
                  }
                },
                {
                  "type": "span",
                  "text": ", 它看起来很乱"
                }
              ]
            },
            {
              "type": "span",
              "text": "是吧",
              "data": {
                "color": "#orange#"
              }
            }
          ]
        }
      ]
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "颜色测试: "
        },
        {
          "type": "span",
          "text": "红",
          "data": {
            "color": "#red#"
          }
        },
        {
          "type": "span",
          "text": "橙",
          "data": {
            "color": "#orange#"
          }
        },
        {
          "type": "span",
          "text": "黄",
          "data": {
            "color": "#yellow#"
          }
        },
        {
          "type": "span",
          "text": "绿",
          "data": {
            "color": "#green#"
          }
        },
        {
          "type": "span",
          "text": "青",
          "data": {
            "color": "#cyan#"
          }
        },
        {
          "type": "span",
          "text": "蓝",
          "data": {
            "color": "#blue#"
          }
        },
        {
          "type": "span",
          "text": "紫",
          "data": {
            "color": "#purple#"
          }
        },
        {
          "type": "span",
          "text": "棕",
          "data": {
            "color": "#brown#"
          }
        },
        {
          "type": "span",
          "text": "灰",
          "data": {
            "color": "#grey#"
          }
        }
      ]
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "颜色测试:"
        },
        {
          "type": "span",
          "text": "红",
          "data": {
            "bgColor": "#redBg#"
          }
        },
        {
          "type": "span",
          "text": "橙",
          "data": {
            "bgColor": "#orangeBg#"
          }
        },
        {
          "type": "span",
          "text": "黄",
          "data": {
            "bgColor": "#yellowBg#"
          }
        },
        {
          "type": "span",
          "text": "绿",
          "data": {
            "bgColor": "#greenBg#"
          }
        },
        {
          "type": "span",
          "text": "青",
          "data": {
            "bgColor": "#cyanBg#"
          }
        },
        {
          "type": "span",
          "text": "蓝",
          "data": {
            "bgColor": "#blueBg#"
          }
        },
        {
          "type": "span",
          "text": "紫",
          "data": {
            "bgColor": "#purpleBg#"
          }
        },
        {
          "type": "span",
          "text": "棕",
          "data": {
            "bgColor": "#brownBg#"
          }
        },
        {
          "type": "span",
          "text": "灰",
          "data": {
            "bgColor": "#greyBg#"
          }
        }
      ]
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "内联代码块也是format:"
        },
        {
          "type": "span",
          "text": "const msg = \"hello1\"",
          "data": {
            "inlineCode": true
          }
        },
        {
          "type": "span",
          "data": {
            "bold": true
          },
          "nodes": [
            {
              "type": "span",
              "data": {
                "italic": true
              },
              "nodes": [
                {
                  "type": "span",
                  "data": {
                    "color": "#red#"
                  },
                  "nodes": [
                    {
                      "type": "span",
                      "text": "ASS"
                    },
                    {
                      "type": "span",
                      "text": "const msg = \"hello2\"",
                      "data": {
                        "inlineCode": true
                      }
                    }
                  ]
                },
                {
                  "type": "span",
                  "text": "const msg = \"hello3\"",
                  "data": {
                    "inlineCode": true,
                    "bgColor": "#blueBg#"
                  }
                }
              ]
            }
          ]
        },
        {
          "type": "span",
          "text": "const msg = \"hello4\"",
          "data": {
            "inlineCode": true
          }
        }
      ]
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "内联代码块也是format:"
        },
        {
          "type": "span",
          "text": "const msg = \"hello1\"",
          "data": {
            "inlineCode": true
          }
        },
        {
          "type": "span",
          "data": {
            "bold": true
          },
          "nodes": [
            {
              "type": "span",
              "data": {
                "italic": true
              },
              "nodes": [
                {
                  "type": "span",
                  "text": "const msg = \"hello6\""
                },
                {
                  "type": "span",
                  "text": "const msg = \"hello7\""
                }
              ]
            }
          ]
        },
        {
          "type": "span",
          "text": "const msg = \"hello4\"",
          "data": {
            "inlineCode": true
          }
        }
      ]
    },
    {
      "type": "title",
      "text": "图片示例"
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "img"
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "img",
      "data": {
        "width": 150
      }
    },
    {
      "type": "paragraph",
      "nodes": [
        {
          "type": "span",
          "text": "http",
          "data": {
            "link": "abc"
          }
        },
        {
          "type": "span",
          "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
        },
        {
          "type": "span",
          "text": "https",
          "data": {
            "link": "abc"
          }
        }
      ]
    },
    {
      "type": "img",
      "data": {
        "width": 300
      }
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "title",
      "text": "table示例"
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "table",
      "nodes": [
        {
          "type": "tableRow",
          "nodes": [
            {
              "type": "tableCell",
              "text": "序号"
            },
            {
              "type": "tableCell",
              "text": "名称"
            },
            {
              "type": "tableCell",
              "text": "价格"
            },
            {
              "type": "tableCell",
              "text": "库存"
            }
          ]
        },
        {
          "type": "tableRow",
          "nodes": [
            {
              "type": "tableCell",
              "text": "1"
            },
            {
              "type": "tableCell",
              "text": "苹果"
            },
            {
              "type": "tableCell",
              "text": "12.5"
            },
            {
              "type": "tableCell",
              "text": "1234"
            }
          ]
        },
        {
          "type": "tableRow",
          "nodes": [
            {
              "type": "tableCell",
              "text": "2"
            },
            {
              "type": "tableCell",
              "text": "橘子"
            },
            {
              "type": "tableCell",
              "text": "25.7"
            },
            {
              "type": "tableCell",
              "text": "63123"
            }
          ]
        },
        {
          "type": "tableRow",
          "nodes": [
            {
              "type": "tableCell",
              "text": "3"
            },
            {
              "type": "tableCell",
              "text": "葡萄"
            },
            {
              "type": "tableCell",
              "text": "22"
            },
            {
              "type": "tableCell",
              "text": "12024"
            }
          ]
        },
        {
          "type": "tableRow",
          "nodes": [
            {
              "type": "tableCell",
              "text": "4"
            },
            {
              "type": "tableCell",
              "text": "草莓"
            },
            {
              "type": "tableCell",
              "text": "53"
            },
            {
              "type": "tableCell",
              "text": "1223"
            }
          ]
        }
      ]
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "independentSelectionDev",
      "nodes": [
        {
          "type": "paragraph",
          "text": "段落1: 内容111"
        },
        {
          "type": "paragraph",
          "text": "段落1: 内容222"
        }
      ]
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "title",
      "text": "quote示例"
    },
    {
      "type": "quote",
      "nodes": [
        {
          "type": "paragraph",
          "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
        }
      ]
    },
    {
      "type": "paragraph",
      "text": "段落可以包含复杂的结构"
    },
    {
      "type": "quote",
      "nodes": [
        {
          "type": "paragraph",
          "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
        },
        {
          "type": "paragraph",
          "nodes": [
            {
              "type": "span",
              "text": "这是"
            },
            {
              "type": "span",
              "text": "https://www.baidu.com/",
              "data": {
                "link": "wwww"
              }
            },
            {
              "type": "span",
              "text": "https://www.google.com/",
              "data": {
                "link": "abc"
              }
            },
            {
              "type": "span",
              "text": "谷歌",
              "data": {
                "link": "aaaaa"
              }
            },
            {
              "type": "span",
              "text": "内"
            }
          ]
        },
        {
          "type": "img",
          "data": {
            "width": 150
          }
        },
        {
          "type": "paragraph",
          "text": "各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作, 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
        },
        {
          "type": "table",
          "nodes": [
            {
              "type": "tableRow",
              "nodes": [
                {
                  "type": "tableCell",
                  "text": "序号"
                },
                {
                  "type": "tableCell",
                  "text": "名称"
                },
                {
                  "type": "tableCell",
                  "text": "价格"
                },
                {
                  "type": "tableCell",
                  "text": "库存"
                }
              ]
            },
            {
              "type": "tableRow",
              "nodes": [
                {
                  "type": "tableCell",
                  "text": "1"
                },
                {
                  "type": "tableCell",
                  "text": "苹果"
                },
                {
                  "type": "tableCell",
                  "text": "12.5"
                },
                {
                  "type": "tableCell",
                  "text": "1234"
                }
              ]
            },
            {
              "type": "tableRow",
              "nodes": [
                {
                  "type": "tableCell",
                  "text": "2"
                },
                {
                  "type": "tableCell",
                  "text": "橘子"
                },
                {
                  "type": "tableCell",
                  "text": "25.7"
                },
                {
                  "type": "tableCell",
                  "text": "63123"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type": "quote",
      "nodes": [
        {
          "type": "table",
          "nodes": [
            {
              "type": "tableRow",
              "nodes": [
                {
                  "type": "tableCell",
                  "text": "序号"
                },
                {
                  "type": "tableCell",
                  "text": "名称"
                },
                {
                  "type": "tableCell",
                  "text": "价格"
                },
                {
                  "type": "tableCell",
                  "text": "库存"
                }
              ]
            },
            {
              "type": "tableRow",
              "nodes": [
                {
                  "type": "tableCell",
                  "text": "1"
                },
                {
                  "type": "tableCell",
                  "text": "苹果"
                },
                {
                  "type": "tableCell",
                  "text": "12.5"
                },
                {
                  "type": "tableCell",
                  "text": "1234"
                }
              ]
            },
            {
              "type": "tableRow",
              "nodes": [
                {
                  "type": "tableCell",
                  "text": "2"
                },
                {
                  "type": "tableCell",
                  "text": "橘子"
                },
                {
                  "type": "tableCell",
                  "text": "25.7"
                },
                {
                  "type": "tableCell",
                  "text": "63123"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "title",
      "text": "编辑器测试",
      "data": { "level": 1 }
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "title",
      "text": "编辑器测试",
      "data": { "level": 2 }
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "title",
      "text": "编辑器测试",
      "data": { "level": 3 }
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "title",
      "text": "编辑器测试",
      "data": { "level": 4 }
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "title",
      "text": "编辑器测试",
      "data": { "level": 5 }
    },
    {
      "type": "paragraph",
      "text": "方法: 各种判断和对比方法,  还重写了常见运算符, 支持用运算符来操作"
    },
    {
      "type": "paragraph",
      "text": "Constraints 可以理解为, 父节点要求子节点在什么范围内, 表现在Box模型的约束类型上,  其拥有 minWidth / maxWidth /  minHeight / maxHeight 四个属性, 其另一个子类是 SliverConstraints"
    },
    { "type": "paragraph", "text": "约束类型: 严格约束Tight 宽松约束loose" },
    {
      "type": "paragraph",
      "text": "严格约束 Tight:  要求是确切的大小, 其最大最小尺寸一致, 紧约束会使自己的尺寸设置失效, 比如使用SIzedBox的时候, 可通过  UnconstrainedBox 解除约束"
    },
    {
      "type": "paragraph",
      "text": "宽松约束 Loose:  最小尺寸为0,  允许子级比自己小,  比如 Center 就能接受严格约束, 但对子级使用宽松约束"
    },
    {
      "type": "paragraph",
      "text": "布局通讯模型,  这种布局模型通讯次数会更少, 从而更高效:"
    },
    { "type": "paragraph", "text": "向下传递约束(Constraints)" },
    { "type": "paragraph", "text": "确定尺寸后向上传递尺寸" },
    { "type": "paragraph", "text": "父级设置子级位置" },
    { "type": "paragraph", "text": "对布局模型更清楚的阐述:" },
    {
      "type": "paragraph",
      "text": "Widget 会通过它的 父级 获得自身的约束。约束实际上就是 4 个浮点类型的集合：最大/最小宽度，以及最大/最小高度。"
    },
    {
      "type": "paragraph",
      "text": "然后，这个 widget 将会逐个遍历它的 children 列表。向子级传递 约束（子级之间的约束可能会有所不同），然后询问它的每一个子级需要用于布局的大小。"
    },
    {
      "type": "paragraph",
      "text": "然后，这个 widget 就会对它子级的 children 逐个进行布局。（水平方向是 x 轴，竖直是 y 轴）, 一个 widget 无法知道，也不需要决定其在屏幕中的位置, 它们的位置由父级决定"
    },
    {
      "type": "paragraph",
      "text": "最后，widget 将会把它的大小信息向上传递至父 widget（包括其原始约束条件）。"
    },
    { "type": "paragraph", "text": "包含图片和每一步沟通的示例" },
    { "type": "paragraph", "text": "image" },
    { "type": "paragraph", "text": "Widget: “嘿！我的父级。我的约束是多少？”" },
    {
      "type": "paragraph",
      "text": "Parent: “你的宽度必须在 0 到 300 像素之间，高度必须在 0 到 85 之间。”"
    },
    {
      "type": "paragraph",
      "text": "Widget: “嗯…我想要 5 个像素的内边距，这样我的子级能最多拥有 290 个像素宽度和 75 个像素高度。”"
    },
    {
      "type": "paragraph",
      "text": "Widget: “嘿，我的第一个子级，你的宽度必须要在 0 到 290，长度在 0 到 75 之间。”"
    },
    {
      "type": "paragraph",
      "text": "First child: “OK，那我想要 290 像素的宽度，20 个像素的长度。”"
    },
    {
      "type": "paragraph",
      "text": "Widget: “嗯…由于我想要将我的第二个子级放在第一个子级下面，所以我们仅剩 55 个像素的高度给第二个子级了。”"
    },
    {
      "type": "paragraph",
      "text": "Widget: “嘿，我的第二个子级，你的宽度必须要在 0 到 290，长度在 0 到 55 之间。”"
    },
    {
      "type": "paragraph",
      "text": "Second child: “OK，那我想要 140 像素的宽度，30 个像素的长度。”"
    },
    {
      "type": "paragraph",
      "text": "Widget: “很好。我的第一个子级将被放在 x: 5 & y: 5 的位置，而我的第二个子级将在 x: 80 & y: 25 的位置。”"
    },
    {
      "type": "paragraph",
      "text": "Widget: “嘿，我的父级，我决定我的大小为 300 像素宽度，60 像素高度。”"
    },
    { "type": "paragraph", "text": "Key" },
    { "type": "paragraph", "text": "Key 在线性协调算法中的作用:" },
    {
      "type": "paragraph",
      "text": "如果两个 widget 的 runtimeType 和 key 属性相同，则新 widget 通过更新底层Element（即，通过使用新 widget 调用Element.Update）, 并且若widget在树中位置改变, element会被移动到新的位置, 包括state。否则，将从树中删除旧Element，将新widget创建为Element，并将新Element插入到树中。"
    },
    {
      "type": "paragraph",
      "text": "解决的问题:   没有key时, 仅通过 runtimeType 无法区分 runtimeType 相同的兄弟节点, LocalKey 系列用来解决相同父级下组件的唯一身份, GlobalKey则是整个应用中的唯一"
    },
    {
      "type": "paragraph",
      "text": "LocalKeys:  用在组件层级范围内的key,  用于标识在同一父级下的子组件, 其中key必须是唯一的"
    },
    {
      "type": "paragraph",
      "text": "常见的有: ValueKey - 用简单值创建的key;   ObjectKey - 用复合值创建的key;   UniqueKey - 无参数创建一个唯一的key"
    },
    {
      "type": "paragraph",
      "text": "GlobalKey:   全局 key 表示其在整个 widget 结构中必须是全局唯一的"
    },
    {
      "type": "paragraph",
      "text": "可以用它来跨组件检索widget和其状态. 可以用 globalKey.currentWidget /  globalKey.currentElement / globalKey.currentState 等api来实现获取key对应组件的信息"
    },
    {
      "type": "paragraph",
      "text": "组件位置变化或在不同地方渲染时, 由于globalKey可以对其进行标识, 可以保证组件任意更换位置而不会丢失状态"
    },
    { "type": "paragraph", "text": "BuildContext" },
    { "type": "paragraph", "text": "概念" },
    {
      "type": "paragraph",
      "text": "context 是 widget 在树中位置的 handle,  context 其实就是当前 widget 所构建的 Element本身, Element 类继承了 BuildContext 接口, 这能阻止直接操作Element对象"
    },
    { "type": "paragraph", "text": "用途和注意事项" },
    {
      "type": "paragraph",
      "text": "依赖查找:  很多路由, 组件等使用都会依赖于传入的context来进行依赖查找, 比如常见的 of 方法"
    },
    {
      "type": "paragraph",
      "text": "查找: 可用来查找节点相关的Element / RenderObject等"
    },
    {
      "type": "paragraph",
      "text": "调整context: Builder 可以用来调整上下文位置, 在需要获取组件上层组件的context而不是当前组件的context时非常有用;   StatefulBuilder 用来获取当前组件子级控件的context, 在弹层类组件中会用到"
    },
    {
      "type": "paragraph",
      "text": "成员属性的widget和build参数的context:  在有状态组件中, 通过 State.context 可作为成员属性在组件内使用, 该成员属性和build中传入的context是始终相同的, 并且在组件生命周期会始终不变, 传入参数仅是为了保证和WidgetBuilder类型的签名匹配"
    },
    {
      "type": "paragraph",
      "text": "异步访问context: 在异步代码中访问context需要注意,  在使用context时当前组件可能已经被卸载了,  需要使用组件的 mounted 进行判断后再调用, 或是把使用context的时机提前"
    },
    { "type": "paragraph", "text": "APIs" },
    {
      "type": "paragraph",
      "text": "常用属性:  mounted - 对应的组件是否挂载在树中   runtimeType - 运行时类型    size - 对应的  RenderBox 尺寸     widget - 对应的控件   owner - 对应的渲染管道 BuildOwner"
    },
    { "type": "paragraph", "text": "常用方法:" },
    { "type": "paragraph", "text": "InheritedElement 相关" },
    {
      "type": "paragraph",
      "text": "dependOnInheritedWidgetOfExactType - 返回最靠近的 InheritedElement 关联的 InheritedWidget 子类, 并注册依赖关系, 在其更改时调用 didChangeDependencies 并 rebuilt"
    },
    {
      "type": "paragraph",
      "text": "通常会在 of() 这类的静态方法中隐式的调用, 调用查找的成本非常低, 不必太过担心多次调用"
    },
    {
      "type": "paragraph",
      "text": "仅在 build / layout / paint / didChangeDependencies 方法内能正常创建依赖关系, 其他位置仅可用于简单的一次性值访问"
    },
    {
      "type": "paragraph",
      "text": "aspect 配置用来指定依赖  InheritedWidget , 用于指定依赖的部分进行更新"
    },
    {
      "type": "paragraph",
      "text": "内部会调用 dependOnInheritedElement - 传入指定的 InheritedElement 注册依赖关系, 在其变更时 rebuilt"
    },
    {
      "type": "paragraph",
      "text": "getInheritedWidgetOfExactType - 类似 dependOnInheritedWidgetOfExactType, 但仅获取, 不建立依赖关系"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    },
    {
      "type": "paragraph",
      "text": "getElementForInheritedWidgetOfExactType - 类似 dependOnInheritedElement, 但仅获取, 不建立依赖关系, 其返回的是 InheritedElement 类型"
    },
    { "type": "paragraph", "text": "查找类方法:" },
    {
      "type": "paragraph",
      "text": "findAncestorRenderObjectOfType - 查找祖先中最靠近的指定 RenderObject 示例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorStateOfType - 查找祖先中最靠近的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findRootAncestorStateOfType - 返回祖先中最远的指定 State 实例"
    },
    {
      "type": "paragraph",
      "text": "findAncestorWidgetOfExactType - 查找祖先中最靠近的指定 Widget 实例"
    },
    {
      "type": "paragraph",
      "text": "findRenderObject - 返回当前小部件的 RenderObject , 如果当前小部件不是 RenderObjectWidget 则查找第一个是的子级"
    },
    { "type": "paragraph", "text": "遍历:" },
    {
      "type": "paragraph",
      "text": "visitAncestorElements - 遍历访问所有父级 Element, 复杂度 O(N)"
    },
    {
      "type": "paragraph",
      "text": "visitChildElements - 遍历访问所有子级 Element, 对只有一个子级的widget非常快, 其他情况为 O(N)"
    },
    {
      "type": "paragraph",
      "text": "dispatchNotification - 为当前 context 的祖先节点派发指定的 Notification 事件"
    },
    { "type": "paragraph", "text": "自绘渲染" },
    {
      "type": "paragraph",
      "text": "场景: 完全自定义的画布, 你可以精确掌握每一个像素"
    },
    {
      "type": "paragraph",
      "text": "CustomPaint -  一个绘制组件,  提供画布来给开发者进行绘制, 它是一个 SingleChildRenderObjectWidget"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制顺序:  当前画布 ->  递归绘制child ->  绘制 foregroundPainter"
    },
    {
      "type": "paragraph",
      "text": "不能在回调内调用 setState markNeedsLayout api, 因为布局帧已发生"
    },
    { "type": "paragraph", "text": "属性" },
    {
      "type": "paragraph",
      "text": "painter / foregroundPainter - 在 child 下方 / 上方进行绘制, 注:  两者都在paint方法中绘制, 动静分离也不会提升性能"
    },
    {
      "type": "paragraph",
      "text": "child - 子 Widget, 显示在绘制内容上,  并决定了默认的绘制区域尺寸"
    },
    {
      "type": "paragraph",
      "text": "size , 绘制区域的尺寸默认由子级决定, 也可以主动由此指定"
    },
    {
      "type": "paragraph",
      "text": "isComplex / willChange : 决定了是否触发绘制缓存,"
    },
    {
      "type": "paragraph",
      "text": "isComplex 为true时, 表示绘制足够复杂, 有必要启用缓存功能,  默认情况下, compositor 会根据算法决定是否有必要缓存"
    },
    {
      "type": "paragraph",
      "text": "在缓存已启用的前提下,  willChange 为 true 表示下一帧中绘制会发生更改,  不使用缓存"
    },
    { "type": "paragraph", "text": "CustomPainter" },
    {
      "type": "paragraph",
      "text": "监听重绘:  构造中传入 Listenable 类型的 repaint 参数, 或是继承来通过父类 Listenable (比如ChangeNotifier) 来直接提供通知, CustomPainter 本身是继承了 Listenable 的"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能包含未定义的行为, 比如超出部门可能会被静默忽略, 或是裁剪,  可在开始绘制前使用 Canvas.clipRect 来保证后续内容只在剪切区域绘制"
    },
    {
      "type": "paragraph",
      "text": "属性:  semanticsBuilder - 用来为绘制提供语义信息"
    },
    { "type": "paragraph", "text": "方法:" },
    {
      "type": "paragraph",
      "text": "实现 paint 方法来定制绘制,  paint接收Canvas, 其包含类似html中canvas的各种绘制api,  完成绘制后传递实例给 CustomPaint 即可进行绘制, 绘制的原点在绘制框的左上角"
    },
    {
      "type": "paragraph",
      "text": "shouldRepaint 用于对比新旧 delegate 对象, 决定是否需要重绘"
    },
    {
      "type": "paragraph",
      "text": "hitTest - 处理命中测试    shouldRebuildSemantics - 应该更新语义化信息"
    },
    {
      "type": "paragraph",
      "text": "addListener / removeListener - 重绘时通知"
    },
    {
      "type": "paragraph",
      "text": "Canvas  - 一个绘制图形的接口，提供了一系列的方法来绘制点、线、路径、矩形、圆形、椭圆、弧形等基础图形，以及复杂的图片和文本, 用于CustomPainter"
    },
    {
      "type": "paragraph",
      "text": "绘制: 包含了各种 draw 开头的绘制方法, 包括 各种图形,  图片,  文本, 阴影等"
    },
    {
      "type": "paragraph",
      "text": "点: drawPoints   drawRawPoints  drawLine  drawVertices"
    },
    { "type": "paragraph", "text": "矩形: drawRect   drawRRect   drawDRRect" },
    { "type": "paragraph", "text": "圆: drawOval  drawCircle   drawArc" },
    {
      "type": "paragraph",
      "text": "图: drawImage   drawImageRect   drawImageNine   drawAtlas  - 绘制图集, 比如一张图片包含多个素材, 将这些素材绘制到画布    drawRawAtlas"
    },
    {
      "type": "paragraph",
      "text": "图片绘制需要 ui.Image 对象,  可通过 rootBundle.load 从资源中读取字节流,  然后通过 decodeImageFromList 将字节流转为 Image 对象"
    },
    { "type": "paragraph", "text": "官方库中的图片绘制工具方法: paintImage" },
    {
      "type": "paragraph",
      "text": "文字: drawParagraph   TextPainter   RenderParagraph"
    },
    {
      "type": "paragraph",
      "text": "其他:  drawColor   drawPath - 直接绘制路径, 非常有用   drawPaint - 使用画笔直接对画布进行滤镜/着色器处理  drawShadow   drawPicture"
    },
    {
      "type": "paragraph",
      "text": "裁剪: clipRect clipPath  clipRRect 可以对绘制区域进行裁剪, 使后续作画仅作用于裁剪区域"
    },
    {
      "type": "paragraph",
      "text": "状态堆栈:  使用 save / saveLayer 和 restore 来在堆栈中保存和恢复当前的 transform clip, 后者会创建新的layer, 要注意正常配对, 防止出现意外的绘制结果,  使用 getSaveCount 可以获取堆栈数量"
    },
    {
      "type": "paragraph",
      "text": "变换: 提供了现成的变换方法, 如 rotate  scale  skew  translate  transform(matrix4) - 4x4的变换矩阵"
    },
    {
      "type": "paragraph",
      "text": "执行变换后, 后续的绘制都在变换后的画布进行"
    },
    {
      "type": "paragraph",
      "text": "在实际绘制时, 我们可以想象是在现实中通过笔和纸进行绘画,  灵活运用变换api来移动/调整纸的位置和角度, 并结合save/restoreapi进行保存回复画布位置, 可以避免一些多余的计算"
    },
    {
      "type": "paragraph",
      "text": "Paint - 可以理解为画笔/原料, 控制在canvas中绘制时后的style, 大多数canvas api都会使用,  用法是通过链式语法设置各个绘制行为, 然后传给对应的api"
    },
    {
      "type": "paragraph",
      "text": "常用的有:   strokeWidth / color    style - 绘制填充还是边缘, 或是两者   shader - 笔画或图形使用的着色器"
    },
    {
      "type": "paragraph",
      "text": "其他有: 混合 / filter滤镜和模糊 / maskFilter 遮罩过滤器 / 质量 / 抗锯齿 / 线头末端和交接处类型  / 斜切类型(strokeMiterLimit, 控制锐角处的表现, 越大锐角就越尖) 等的控制"
    },
    { "type": "paragraph", "text": "注意事项:" },
    {
      "type": "paragraph",
      "text": "绘制时, 线宽的一半在线条的位置外, 一半在其内, 大线宽绘制时需要进行调整来使其位置正确"
    },
    { "type": "paragraph", "text": "Path" },
    {
      "type": "paragraph",
      "text": "包含了画线, 弧度(arc), 圆锥曲线(conic), 贝塞尔曲线(bezier, cubic), 各种基础新状的绘制"
    },
    {
      "type": "paragraph",
      "text": "绝对路径: moveTo   lineTo   quadraticBezierTo   cubicTo   conicTo   arcTo   arcToPoint"
    },
    {
      "type": "paragraph",
      "text": "相对路径: relativeMoveTo   relativeLineTo   relativeQuadraticBezierTo   relativeCubicTo   relativeConicTo    relativeArcToPoint"
    },
    {
      "type": "paragraph",
      "text": "添加其他路径/图形:  addRect   addRRect   addOval   addArc   addPolygon   addPath   extendWithPath"
    },
    {
      "type": "paragraph",
      "text": "操作:  close   reset   contains - 判断点在否路径内   shift - 指定offset返回移动后的新路径   transform   getBounds   fillType   computeMetrics - 测量和获取路径的详细信息, 比如长度/索引/某个比例所在的点等, 可用来实现路径移动动画等效果   #combine - 组合路径, 有多种覆盖显示的方式"
    },
    { "type": "paragraph", "text": "成品绘制&着色器:" },
    {
      "type": "paragraph",
      "text": "RadialGradient / Gradient.linear / Gradient.radial / Gradient.sweep - 绘制渐变, 可用于路径实现渐变路径"
    },
    { "type": "paragraph", "text": "ImageShader - 可实现图片作为绘制路径等" },
    { "type": "paragraph", "text": "ColorFilter - 实现滤镜" },
    { "type": "paragraph", "text": "MaskFilter- 实现模糊" },
    { "type": "paragraph", "text": "imageFilter - 图片模糊/变换等" },
    { "type": "paragraph", "text": "filterQuality - 图片质量" },
    {
      "type": "paragraph",
      "text": "其他:   BlendMode 在像素出现堆叠时, 用来合成像素的算法"
    },
    { "type": "paragraph", "text": "性能 & 杂项:" },
    {
      "type": "paragraph",
      "text": "最好通过 isComplex  willChange 来减少不必要的绘制;   使用不同的组件来实现不同的层而不是全都通过一个组件绘制, 比如棋盘和棋子"
    },
    {
      "type": "paragraph",
      "text": "在CustomPaint和一些组件处于同一children中时, 他们会在同一画布下绘制,  这时如果相邻的组件更新会导致CustomPaint也反复的重绘, 即使他设置了 willChange,  可通过 RepaintBoundary 组件包裹 CustomPaint 的 child, 使其在单独的层中绘制防止浪费性能, RepaintBoundary也可以用在其他普通组件的绘制下, 用来创建单独的绘制层"
    },
    {
      "type": "paragraph",
      "text": "框架会使用尽可能少的 Canvas 来绘制, 也就是说即使使用两个不同的 CustomPainter , 它们的 Canvas 可能是一个,  在添加 BlendMode 时可能会有显示问题,  可通过 Canvas.saveLayer / Canvas.restore 在新的layer中绘制来避免"
    },
    {
      "type": "paragraph",
      "text": "绘制超过可用的矩形区域时, 可能会由于没有足够的内存分配给绘画指令而导致未定义的行为, 可将 CustomPaint 包裹在 ClipRect 来解决"
    },
    {
      "type": "paragraph",
      "text": "在runApp前设置 debugRepaintRainbowEnable = true; 可以使发生变更的绘制区域高亮边框突出显示"
    },
    { "type": "paragraph", "text": "动画实现的几个思路:" },
    { "type": "paragraph", "text": "自行维护一个动画状态,   在每一帧更新动画" },
    {
      "type": "paragraph",
      "text": "使用 AnimationController + SingleTickerProviderStateMixin,  painter 的 repaint 入参会接收一个可监听对象, 直接传入动画控制器, 它会自动在动画变更时绘制"
    }
  ]
}
